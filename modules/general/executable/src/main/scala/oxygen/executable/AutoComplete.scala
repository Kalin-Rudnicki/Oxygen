package oxygen.executable

import java.nio.file.*
import oxygen.cli.*
import oxygen.cli.error.*
import oxygen.executable.error.*
import oxygen.json.KeyedMapDecoder
import oxygen.predef.core.*
import oxygen.predef.zio.*
import oxygen.zio.JarUtils
import oxygen.zio.logging.*
import scala.annotation.tailrec

object AutoComplete {

  private def generateScriptText(
      jarPath: String,
      relativeScriptPath: String,
      scriptPath: String,
      baseName: String,
      programArgs: List[String],
  ): String = {
    val functionName: String = s"__oxygen_cli_complete__$baseName"
    val programArgsString: String =
      if programArgs.nonEmpty then s"\n         ${programArgs.map(_.unesc("\"")).mkString(" ")} \\"
      else ""

    s"""#!/bin/bash
       |
       |# ====================================================================================================
       |# This script has been auto-generated by `oxygen-executable`.
       |# ====================================================================================================
       |
       |jar_path="$jarPath"
       |script_path="$scriptPath"
       |base_name="$baseName"
       |
       |$functionName() {
       |  local comp__join_str=$$'\\n-----separator-----\\n'
       |
       |  local comp__num_words=$$(( $${#COMP_WORDS[@]} - 1 ))
       |  local comp__command=""
       |  local comp__acc_args=""
       |  local comp__arg_idx=$$(( COMP_CWORD - 1 ))
       |
       |  for tmp_word in "$${COMP_WORDS[@]}"; do
       |    if [[ -z "$$comp__command" ]]; then
       |      comp__command="$$tmp_word"
       |    elif [[ -z "$$comp__acc_args" ]]; then
       |      comp__acc_args="$$tmp_word"
       |    else
       |      comp__acc_args="$$comp__acc_args$$comp__join_str$$tmp_word"
       |    fi
       |  done
       |
       |  comp__raw_result=$$( \\
       |    OXYGEN_CLI_COMPLETE__NUM_WORDS="$$comp__num_words" \\
       |    OXYGEN_CLI_COMPLETE__ARG_IDX="$$comp__arg_idx" \\
       |    OXYGEN_CLI_COMPLETE__COMMAND="$$comp__command" \\
       |    OXYGEN_CLI_COMPLETE__ACC_ARGS="$$comp__acc_args" \\
       |    OXYGEN_CLI_COMPLETE__JOIN_STR="$$comp__join_str" \\
       |    OXYGEN_CLI_COMPLETE__RAW_STR="$$COMP_LINE" \\
       |    OXYGEN_CLI_COMPLETE__RAW_IDX="$$COMP_POINT" \\
       |    java -jar $jarPath --: complete \\
       |  )
       |  comp__return_code="$$?"
       |
       |  case "$$comp__return_code" in
       |    0)
       |      if [[ -z "$$comp__raw_result" ]]; then
       |        COMPREPLY=()
       |      else
       |        declare -a TMP_ARRAY=()
       |
       |        mapfile -d $$'\\0' -t TMP_ARRAY < <(
       |          printf "%s" "$$comp__raw_result" | awk -v RS='' -v FS="$$comp__join_str" '
       |            BEGIN{ ORS="\\0" }
       |            {
       |            for (i=1; i<=NF; i++) {
       |                print $$i
       |            }
       |          }'
       |        )
       |
       |        COMPREPLY=("$${TMP_ARRAY[@]}")
       |      fi
       |      ;;
       |    *)
       |      echo ""
       |      echo ""
       |      echo "error during command completion, received return code $$comp__return_code"
       |      echo "$$comp__raw_result" >&2
       |      ;;
       |  esac
       |
       |  return $$(( comp__return_code ))
       |}
       |
       |if [[ "$$1" == "--:" && "$$2" == "export" ]]; then
       |    alias $baseName="$scriptPath"
       |    # TODO (KR) : Figure out how to get { } to behave nicely.
       |    complete -F $functionName $scriptPath
       |    complete -F $functionName $baseName
       |    complete -F $functionName $relativeScriptPath
       |else
       |    java -jar $jarPath \\$programArgsString
       |         "$$@"
       |fi
       |""".stripMargin
  }

  private def generateScript(path: String, programArgs: List[String]): Task[Unit] =
    for {
      scriptPath <- ZIO.attempt { Paths.get(path).toAbsolutePath }
      parentPath <- ZIO.attempt { scriptPath.getParent }
      fileName <- ZIO.attempt { scriptPath.getFileName.toString }
      strippedFileName = fileName.stripSuffix(".sh")

      jarPath <- JarUtils.getJarFile
      scriptText = generateScriptText(jarPath, path, scriptPath.toString, strippedFileName, programArgs)

      _ <- ZIO.attempt { Files.createDirectories(parentPath) }.unlessZIO(ZIO.attempt { Files.exists(parentPath) })
      _ <- ZIO.writeFile(scriptPath.toString, scriptText)
      _ <- Command("chmod")("+x", scriptPath.toString).executeSuccess()

      _ <- Console.printLine(s"\nGenerated script at: $scriptPath\nSource command:\n\n. $scriptPath --: export\n")
    } yield ()

  private def getEnvVar[A: StringDecoder as dec](key: String): Task[A] =
    System.env(key).someOrFail(new RuntimeException(s"Missing expected env-var '$key'")).flatMap { valueStr =>
      dec.decodeSimple(valueStr) match {
        case Right(value) => ZIO.succeed(value)
        case Left(error)  => ZIO.fail(new RuntimeException(s"Error decoding env-var '$key': $error"))
      }
    }

  private enum SpecialLeafCase { case Empty, Equals, SingleDash, DoubleDash }

  private sealed trait ParseScope {

    final def toIndentedString: IndentedString =
      this match {
        case ParseScope.Leaf(arg)                   => arg.toString
        case ParseScope.Param(param, inner)         => IndentedString.section(param.toString)(inner.toIndentedString)
        case ParseScope.Bracketed(bracketed, inner) => IndentedString.section(bracketed.toString)(inner.toIndentedString)
      }

    override final def toString: String = toIndentedString.toString

  }
  private object ParseScope {

    final case class Leaf(arg: Arg) extends ParseScope {

      lazy val leafCase: Option[SpecialLeafCase] = arg match
        case Arg.Value(_, "")   => SpecialLeafCase.Empty.some
        case Arg.Value(_, "=")  => SpecialLeafCase.Equals.some
        case Arg.Value(_, "-")  => SpecialLeafCase.SingleDash.some
        case Arg.Value(_, "--") => SpecialLeafCase.DoubleDash.some
        case _                  => None

      lazy val isSpecialNonEquals: Boolean = leafCase match
        case Some(SpecialLeafCase.Equals) | None => false
        case _                                   => true

    }

    final case class Param(param: Arg.ScopedParam, inner: ParseScope) extends ParseScope {

      lazy val hasLeadingEquals: Boolean = param.values match
        case Arg.Value(_, "=") :: _ => true
        case _                      => false

      lazy val valuesIgnoringEquals: List[Arg.ValueLike] =
        if hasLeadingEquals then param.values.tail else param.values

      lazy val innerLeafCase: Option[SpecialLeafCase] = inner match
        case leaf: Leaf => leaf.leafCase
        case _          => None

      lazy val innerIsSpecialNonEquals: Boolean = inner match
        case leaf: Leaf => leaf.isSpecialNonEquals
        case _          => false

    }

    final case class Bracketed(bracketed: Arg.Bracketed, inner: ParseScope) extends ParseScope

    def parse(
        completeIdx: Int,
        valueArgs: List[Arg.ValueLike],
        paramArgs: List[Arg.ParamLike],
    ): Option[ParseScope] = {
      val map: Map[Int, Arg] =
        (for {
          a <- valueArgs ::: paramArgs
          i <- a.selfAndChildIndices.toList
        } yield (i, a)).toMap

      map.get(completeIdx) match
        case Some(p) if p.index == completeIdx => Leaf(p).some
        case Some(p: Arg.ScopedParam)          => parse(completeIdx, p.values, Nil).map(Param(p, _))
        case Some(p: Arg.Bracketed)            => parse(completeIdx, p.values, p.params).map(Bracketed(p, _))
        case _                                 => None
    }

  }

  private enum ValueCompletion {

    case Enum(values: Seq[String])

    final def complete(value: String): List[String] =
      this match {
        case ValueCompletion.Enum(values) =>
          val low = value.toLowerCase
          val matched: Seq[String] = values.filter(_.toLowerCase.startsWith(low))
          (if matched.nonEmpty then matched else values).toList
      }

  }
  private object ValueCompletion {

    def fromHint(hint: HelpHint): Option[ValueCompletion] = hint match
      case HelpHint.EnumValues(values) => Enum(values).some
      case _                           => None

  }

  private sealed trait FlattenedParsers {

    final def toIndentedString: IndentedString =
      this match {
        case FlattenedParsers.SimpleValue(name, Nil)         => s"[value] $name"
        case FlattenedParsers.SimpleValue(name, completions) =>
          IndentedString.section(s"[value] $name")(
            IndentedString.section("completions:")(completions.map(_.toString)),
          )
        case FlattenedParsers.Bracketed(name, NonEmptyList(values, Nil), params) =>
          IndentedString.section(s"[bracketed] $name")(
            IndentedString.section("values:")(values.map(_.toIndentedString)*),
            IndentedString.section("params:")(params.map(_.toIndentedString)*),
          )
        case FlattenedParsers.Bracketed(name, values, params) =>
          IndentedString.section(s"[bracketed] $name")(
            IndentedString.section("values:")(
              values.toList.zipWithIndex.map { case (values, i) =>
                IndentedString.section(s"values[$i]:")(values.map(_.toIndentedString)*)
              },
            ),
            IndentedString.section("params:")(params.map(_.toIndentedString)*),
          )
        case FlattenedParsers.ParamWithValues(name, NonEmptyList(values, Nil)) =>
          IndentedString.section(s"[param] $name")(
            IndentedString.section("values:")(values.map(_.toIndentedString)*),
          )
        case FlattenedParsers.ParamWithValues(name, values) =>
          IndentedString.section(s"[param] $name")(
            IndentedString.section("values:")(
              values.toList.zipWithIndex.map { case (values, i) =>
                IndentedString.section(s"values[$i]:")(values.map(_.toIndentedString)*)
              },
            ),
          )
        case FlattenedParsers.ParamNoValues(name) => s"[param] $name"
      }

    override final def toString: String = toIndentedString.toString

  }
  private object FlattenedParsers {

    sealed trait ValueLike extends FlattenedParsers
    sealed trait ParamLike extends FlattenedParsers {
      val name: SimpleName
      val values: NonEmptyList[List[FlattenedParsers.ValueLike]]
    }

    final case class SimpleValue(name: LongName, completions: List[ValueCompletion]) extends ValueLike {

      def complete(value: String): List[String] =
        completions.flatMap(_.complete(value))

    }
    final case class Bracketed(name: LongName, values: NonEmptyList[List[FlattenedParsers.ValueLike]], params: List[FlattenedParsers.ParamLike]) extends ValueLike

    final case class ParamWithValues(name: SimpleName, values: NonEmptyList[List[FlattenedParsers.ValueLike]]) extends ParamLike
    final case class ParamNoValues(name: SimpleName) extends ParamLike {
      override val values: NonEmptyList[List[ValueLike]] = NonEmptyList.one(Nil)
    }

    private val empty: (NonEmptyList[List[FlattenedParsers.ValueLike]], List[FlattenedParsers.ParamLike]) =
      (NonEmptyList.one(Nil), Nil)

    private def fromValues(p: Values[?]): NonEmptyList[List[FlattenedParsers.ValueLike]] =
      p match {
        case Values.Const(_)                   => NonEmptyList.one(Nil)
        case Values.SingleValue(name, hints)   => NonEmptyList.one(SimpleValue(name, hints.flatMap(ValueCompletion.fromHint)) :: Nil)
        case Values.Raw(_, _)                  => NonEmptyList.one(Nil)
        case Values.Bracketed(name, parser, _) =>
          val (values, params) = from(parser)
          NonEmptyList.one(Bracketed(name, values, params) :: Nil)
        case Values.Ignored                      => NonEmptyList.one(Nil)
        case Values.Optional(parser, _)          => fromValues(parser)
        case Values.Repeated(parser, _)          => fromValues(parser)
        case Values.RepeatedNel(parser, _)       => fromValues(parser)
        case Values.WithDefault(parser, _, _, _) => fromValues(parser)
        case Values.Mapped(parser, _)            => fromValues(parser)
        case Values.MappedOrFail(parser, _)      => fromValues(parser)
        case Values.Then(a, b, _)                =>
          for {
            l <- fromValues(a)
            r <- fromValues(b)
          } yield l ::: r
        case Values.Or(left, right) =>
          (fromValues(left) ::: fromValues(right)).distinct
      }

    private def fromParams(p: Params[?]): List[FlattenedParsers.ParamLike] =
      p match {
        case Params.Const(_)                                                      => Nil
        case Params.ParamWithValues(longName, shortName, aliases, _, valueParser) =>
          val names: List[SimpleName] =
            List(
              longName :: Nil,
              shortName.toOption.toList,
              aliases,
            ).flatten
          val v = fromValues(valueParser)
          names.map(ParamWithValues(_, v))
        case Params.IfPresent(longName, shortName, aliases, _, _) =>
          val names: List[SimpleName] =
            List(
              longName :: Nil,
              shortName.toOption.toList,
              aliases,
            ).flatten
          names.map(ParamNoValues(_))
        case Params.BooleanToggle(longName, shortName, aliases, _) =>
          val names: List[SimpleName] =
            List(
              longName.trueName :: longName.falseName :: Nil,
              shortName.toOption.toList.flatMap { shortName => shortName.trueName :: shortName.falseName :: Nil },
              aliases.flatMap { alias => alias.trueName :: alias.falseName :: Nil },
            ).flatten
          names.map(ParamNoValues(_))
        case Params.Raw(_, _)                  => Nil
        case Params.Ignored                    => Nil
        case Params.Optional(parser)           => fromParams(parser)
        case Params.Repeated(parser)           => fromParams(parser)
        case Params.RepeatedNel(parser)        => fromParams(parser)
        case Params.WithDefault(parser, _, _)  => fromParams(parser)
        case Params.Mapped(parser, _)          => fromParams(parser)
        case Params.MappedOrFail(parser, _)    => fromParams(parser)
        case Params.And(left, right, _)        => fromParams(left) ::: fromParams(right)
        case Params.FirstOfByArgIndex(options) => options.toList.flatMap(fromParams)
        case Params.Or(left, right)            => fromParams(left) ::: fromParams(right)
      }

    def from(p: Parser[?]): (NonEmptyList[List[FlattenedParsers.ValueLike]], List[FlattenedParsers.ParamLike]) =
      p match {
        // root
        case Parser.Empty                => empty
        case Parser.Const(_)             => empty
        case Parser.Then(left, right, _) =>
          val (lv, lp) = from(left)
          val (rv, rp) = from(right)
          (
            for {
              l <- lv
              r <- rv
            } yield l ::: r,
            lp ::: rp,
          )
        case Parser.Or(left, right) =>
          val (lv, lp) = from(left)
          val (rv, rp) = from(right)
          ((lv ::: rv).distinct, lp ::: rp)
        case Parser.Mapped(parser, _)       => from(parser)
        case Parser.MappedOrFail(parser, _) => from(parser)

        // values/params
        case p: Values[?] => (fromValues(p), Nil)
        case p: Params[?] => (NonEmptyList.one(Nil), fromParams(p))
      }

  }

  @tailrec
  private def findParser(
      exe: Executable,
      consumedIndices: Int,
      completeIdx: Int,
      placeholderCtx: ExecutableContext,
      valueArgs: List[Arg.ValueLike],
      paramArgs: List[Arg.ParamLike],
  ): Task[List[String]] =
    exe match {
      case exe: Executable.Single if consumedIndices == 0 =>
        scopeAndBuild(exe.getCliParser(placeholderCtx), completeIdx, valueArgs, paramArgs)
      case exe: Executable.Single =>
        scopeAndBuild(exe.getCliParser(placeholderCtx), completeIdx, valueArgs.map(_.subtractIdx(consumedIndices)), paramArgs.map(_.subtractIdx(consumedIndices)))
      case many: Executable.Many =>
        (valueArgs, completeIdx) match {
          case (Arg.Value(_, value) :: _, 0) =>
            val subCommandNames: List[String] = many.options.toList.map(_._1)
            val matchingNames: List[String] = subCommandNames.filter(_.startsWith(value))
            ZIO.succeed(if matchingNames.isEmpty then subCommandNames else matchingNames)
          case (Arg.Value(_, value) :: vArgN, _) =>
            many.optionMap.get(value) match {
              case Some(newExe) => findParser(newExe, consumedIndices + 1, completeIdx - 1, placeholderCtx, vArgN, paramArgs)
              case None         => ZIO.succeed(Nil) // what to do? invalid sub-command, but not the command we are trying to complete
            }
          case _ =>
            ZIO.succeed(Nil) // what to do? still a `many`, but no more sub-commands to parse
        }
    }

  private def doTheMagic(
      valueArgs: List[Arg.ValueLike],
      scope: ParseScope,
      valueParsers: NonEmptyList[List[FlattenedParsers.ValueLike]],
      paramParsers: List[FlattenedParsers.ParamLike],
  ): Task[List[String]] = {
    val paramMap: Map[String, FlattenedParsers.ParamLike] =
      paramParsers.map(p => p.name.nameWithDashes -> p).toMap

    scope match {
      case ParseScope.Leaf(p: Arg.ScopedParam) if p.values.isEmpty =>
        val allOpts: List[String] = paramMap.keySet.toList.sorted
        val matchingOpts: List[String] = allOpts.filter(_.startsWith(p.name.nameWithDashes))
        ZIO.succeed(if matchingOpts.nonEmpty then matchingOpts else allOpts)
      case scope @ ParseScope.Leaf(Arg.Value(vIdx, value)) if scope.isSpecialNonEquals =>
        val removedValues: List[Arg.ValueLike] = valueArgs.filter(_.index < vIdx)
        val remaining: List[FlattenedParsers.SimpleValue] = valueParsers.toList.flatMap(_.drop(removedValues.size).headOption).collect { case v: FlattenedParsers.SimpleValue => v }
        if remaining.nonEmpty then ZIO.succeed(remaining.flatMap(_.complete(value)))
        else {
          val allOpts: List[String] = paramMap.keySet.toList.sorted
          val matchingOpts: List[String] = allOpts.filter(_.startsWith(value))
          ZIO.succeed(if matchingOpts.nonEmpty then matchingOpts else allOpts)
        }
      case scope: ParseScope.Param if scope.hasLeadingEquals && scope.valuesIgnoringEquals.isEmpty =>
        // attempting to complete "--param=|"
        paramMap.get(scope.param.name.nameWithDashes) match {
          case Some(paramLike: FlattenedParsers.ParamLike) =>
            val headValues: List[FlattenedParsers.SimpleValue] = paramLike.values.toList.flatMap(_.headOption).collect { case v: FlattenedParsers.SimpleValue => v }
            ZIO.succeed(headValues.flatMap(_.complete("")).map(s => s"=$s"))
          case _ =>
            ZIO.succeed(Nil)
        }
      case scope: ParseScope.Param =>
        (paramMap.get(scope.param.name.nameWithDashes), scope.inner) match {
          case (Some(paramLike: FlattenedParsers.ParamLike), ParseScope.Leaf(Arg.Value(vIdx, value))) =>
            val removedValues: List[Arg.ValueLike] = scope.valuesIgnoringEquals.filter(_.index < vIdx)
            val remaining: List[FlattenedParsers.SimpleValue] = paramLike.values.toList.flatMap(_.drop(removedValues.size).headOption).collect { case v: FlattenedParsers.SimpleValue => v }
            if remaining.nonEmpty then // TODO (KR) : does this need to be smarter?
              ZIO.succeed(remaining.flatMap(_.complete(value)))
            else {
              val allOpts: List[String] = paramMap.keySet.toList.sorted
              val matchingOpts: List[String] = allOpts.filter(_.startsWith(value))
              ZIO.succeed(if matchingOpts.nonEmpty then matchingOpts else allOpts)
            }
          case _ =>
            ZIO.succeed(Nil)
        }

      // ignoring bracketed handling for the time being, bash doesnt seem to even call completion properly in those cases anyway
      case _ =>
        ZIO.succeed(Nil)
    }
  }

  private def scopeAndBuild(
      parser: Parser[?],
      completeIdx: Int,
      valueArgs: List[Arg.ValueLike],
      paramArgs: List[Arg.ParamLike],
  ): Task[List[String]] =
    ParseScope.parse(completeIdx, valueArgs, paramArgs) match {
      case Some(parseScope) =>
        parser.build.toOption match {
          case Some(built) =>
            val (values, params) = FlattenedParsers.from(built)
            doTheMagic(valueArgs, parseScope, values, params)
          case None =>
            ZIO.succeed(Nil)
        }
      case None =>
        ZIO.succeed(Nil)
    }

  private def cleanAndParse(
      uncleanArgs: List[String],
      completeIdx: Int,
      placeholderCtx: ExecutableContext,
      executable: Option[Executable],
  ): Task[List[String]] = {

    val cleanedArgs = uncleanArgs.map {
      case a if a.startsWith("\"") => a.stripPrefix("\"").stripSuffix("\"")
      case a if a.startsWith("'")  => a.stripPrefix("'").stripSuffix("'")
      case a                       => a
    }

    for {
      (valueArgs, paramArgs) <- ZIO.fromEither(Arg.parse(cleanedArgs)).mapError(error => ExecuteError.Parsing.FailedToParse(ParseError.UnableToParseArgs(error), HelpMessage.RootMessage.Empty))
      res <- executable match
        case Some(executable) => findParser(executable, 0, completeIdx, placeholderCtx, valueArgs, paramArgs)
        case None             => scopeAndBuild(ExecutableApp.Config.parser, completeIdx, valueArgs, paramArgs)
    } yield res
  }

  private def autoComplete(executableApp: ExecutableApp): Task[Unit] =
    for {
      cliNumWords <- getEnvVar[Int]("OXYGEN_CLI_COMPLETE__NUM_WORDS")
      cliArgIdx <- getEnvVar[Int]("OXYGEN_CLI_COMPLETE__ARG_IDX")
      cliAccArgs <- getEnvVar[String]("OXYGEN_CLI_COMPLETE__ACC_ARGS")
      cliJoinStr <- getEnvVar[String]("OXYGEN_CLI_COMPLETE__JOIN_STR")

      // TODO (KR) : potentially do smarter things here?
      //           : current known issue is that readline really doesnt seem to like curly braces
      // cliCommand <- getEnvVar[String]("OXYGEN_CLI_COMPLETE__COMMAND")
      // cliRawStr <- getEnvVar[String]("OXYGEN_CLI_COMPLETE__RAW_STR")
      // cliRawIdx <- getEnvVar[Int]("OXYGEN_CLI_COMPLETE__RAW_IDX")
      // inputStr = cliRawStr.stripPrefix(cliCommand).stripLeading
      // inputIdx = cliRawIdx + inputStr.length - cliRawStr.length

      args = cliAccArgs.detailedSplit(scala.util.matching.Regex.quote(cliJoinStr).r, true, true).toList
      _ <- ZIO.fail(new RuntimeException(s"args.length (${args.length}) != cliNumWords ($cliNumWords)")).unless(args.length == cliNumWords)
      _ <- ZIO.fail(new RuntimeException(s"cliArgIdx ($cliArgIdx) >= cliNumWords ($cliNumWords)")).unless(cliArgIdx < cliNumWords)

      placeholderCtx = ExecutableContext(
        logTargetDecoder = KeyedMapDecoder(LogConfig.elemDecoders.default ++ executableApp.additionalLoggerDecoders),
        additionalLoggerParsers = executableApp.additionalLoggerParsers,
        executableConfig = ExecutableApp.Config(Nil, false),
        oxygenLoggerDefaults = OxygenLoggerDefaults.all(),
      )

      doubleDashIndices = args.zipWithIndex.collect { case ("--", i) => i }
      minOtherDoubleDashIdx = doubleDashIndices.filterNot(_ == cliArgIdx).minOption
      validArgs <- minOtherDoubleDashIdx match {
        case Some(minOtherDoubleDashIdx) if minOtherDoubleDashIdx < cliArgIdx =>
          cleanAndParse(args.drop(minOtherDoubleDashIdx + 1), cliArgIdx - minOtherDoubleDashIdx - 1, placeholderCtx, executableApp.executable.some)
        case Some(minOtherDoubleDashIdx) if minOtherDoubleDashIdx > cliArgIdx =>
          cleanAndParse(args.take(minOtherDoubleDashIdx), cliArgIdx, placeholderCtx, None)
        case _ =>
          cleanAndParse(args, cliArgIdx, placeholderCtx, executableApp.executable.some)
      }

      // TODO (KR) : handle spaces/newlines/etc
      cleanedValidArgs = validArgs.distinct.sorted

      _ <- Console.printLine(cleanedValidArgs.mkString(cliJoinStr))
    } yield ()

  def handleArgs(args: List[String], executableApp: ExecutableApp): IO[ExecuteError, Unit] = {
    lazy val base: IO[ExecuteError, Unit] =
      args match {
        case "generate" :: path :: "--oxygen-args" :: programArgs =>
          generateScript(path, programArgs :+ "--").mapError {
            case err: ExecuteError => err
            case err               => ExecuteError.ProgramError(err)
          }
        case "generate" :: path :: "--args" :: programArgs =>
          generateScript(path, programArgs).mapError {
            case err: ExecuteError => err
            case err               => ExecuteError.ProgramError(err)
          }
        case "generate" :: path :: Nil =>
          generateScript(path, Nil).mapError {
            case err: ExecuteError => err
            case err               => ExecuteError.ProgramError(err)
          }
        case "complete" :: Nil =>
          autoComplete(executableApp).mapError {
            case err: ExecuteError => err
            case err               => ExecuteError.ProgramError(err)
          }
        case _ =>
          val msg: String =
            """Invalid special command, supported:
                  |
                  |generate script <path>
                  |generate script <path> --oxygen-args <program-args*>
                  |generate script <path> --args <program-args*>
                  |resolve complete
                  |""".stripMargin
          ZIO.fail(ExecuteError.help(msg))
      }

    LogConfig.usingConfig(LogConfig.oxygenDefault).set *> base
  }

}
