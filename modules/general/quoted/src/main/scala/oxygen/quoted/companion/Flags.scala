package oxygen.quoted.companion

import oxygen.quoted.*
import scala.quoted.*

final class FlagsCompanion(using quotes: Quotes) {

  /** The empty set of flags */
  def EmptyFlags: Flags = Flags.wrap(quotes.reflect.Flags.EmptyFlags)

  /** Is this symbol `abstract` */
  def Abstract: Flags = Flags.wrap(quotes.reflect.Flags.Abstract)

  /**
    * Is this an abstract override method?
    *
    *  This corresponds to a definition declared as "abstract override def" in the source.
    *  See https://stackoverflow.com/questions/23645172/why-is-abstract-override-required-not-override-alone-in-subtrait for examples.
    */
  def AbsOverride: Flags = Flags.wrap(quotes.reflect.Flags.AbsOverride)

  /**
    * Is this generated by Scala compiler.
    *  Corresponds to ACC_SYNTHETIC in the JVM.
    */
  def Artifact: Flags = Flags.wrap(quotes.reflect.Flags.Artifact)

  /** Is this symbol `case` */
  def Case: Flags = Flags.wrap(quotes.reflect.Flags.Case)

  /** Is this symbol a getter for case class parameter */
  def CaseAccessor: Flags = Flags.wrap(quotes.reflect.Flags.CaseAccessor)

  /** Is this symbol a type parameter marked as contravariant `-` */
  def Contravariant: Flags = Flags.wrap(quotes.reflect.Flags.Contravariant)

  /** Is this symbol a type parameter marked as covariant `+` */
  def Covariant: Flags = Flags.wrap(quotes.reflect.Flags.Covariant)

  /** Is a declared, but not defined member */
  def Deferred: Flags = Flags.wrap(quotes.reflect.Flags.Deferred)

  /** Is this symbol an enum */
  def Enum: Flags = Flags.wrap(quotes.reflect.Flags.Enum)

  /** Is this symbol `erased` */
  def Erased: Flags = Flags.wrap(quotes.reflect.Flags.Erased)

  /** Is this symbol exported from provided instance */
  def Exported: Flags = Flags.wrap(quotes.reflect.Flags.Exported)

  /** Is this symbol a `def` defined in an `extension` */
  def ExtensionMethod: Flags = Flags.wrap(quotes.reflect.Flags.ExtensionMethod)

  /** Is this symbol a getter or a setter */
  def FieldAccessor: Flags = Flags.wrap(quotes.reflect.Flags.FieldAccessor)

  /** Is this symbol `final` */
  def Final: Flags = Flags.wrap(quotes.reflect.Flags.Final)

  /** Is this symbol an inferable ("given") parameter */
  def Given: Flags = Flags.wrap(quotes.reflect.Flags.Given)

  /** Is this symbol a parameter with a default value? */
  def HasDefault: Flags = Flags.wrap(quotes.reflect.Flags.HasDefault)

  /** Is this symbol `implicit` */
  def Implicit: Flags = Flags.wrap(quotes.reflect.Flags.Implicit)

  /** Is an infix method or type */
  def Infix: Flags = Flags.wrap(quotes.reflect.Flags.Infix)

  /** Is this symbol `inline` */
  def Inline: Flags = Flags.wrap(quotes.reflect.Flags.Inline)

  /** Is this symbol invisible when typechecking? */
  def Invisible: Flags = Flags.wrap(quotes.reflect.Flags.Invisible)

  /** Is this symbol defined in a Java class */
  def JavaDefined: Flags = Flags.wrap(quotes.reflect.Flags.JavaDefined)

  /** Is implemented as a Java static */
  def JavaStatic: Flags = Flags.wrap(quotes.reflect.Flags.JavaStatic)

  /** Is this an annotation defined in Java */
  def JavaAnnotation: Flags = Flags.wrap(quotes.reflect.Flags.JavaAnnotation)

  /** Is this symbol `lazy` */
  def Lazy: Flags = Flags.wrap(quotes.reflect.Flags.Lazy)

  /** Is this symbol local? Used in conjunction with private/private[T] to mean private[this] extends Modifier protected[this] */
  def Local: Flags = Flags.wrap(quotes.reflect.Flags.Local)

  /** Is this symbol marked as a macro. An inline method containing top level splices */
  def Macro: Flags = Flags.wrap(quotes.reflect.Flags.Macro)

  /** Is this symbol `def` */
  def Method: Flags = Flags.wrap(quotes.reflect.Flags.Method)

  /** Is this symbol an object or its class (used for a ValDef or a ClassDef extends Modifier respectively) */
  def Module: Flags = Flags.wrap(quotes.reflect.Flags.Module)

  /** Is this symbol a `var` (when used on a ValDef) */
  def Mutable: Flags = Flags.wrap(quotes.reflect.Flags.Mutable)

  /** Trait does not have fields or initialization code. */
  def NoInits: Flags = Flags.wrap(quotes.reflect.Flags.NoInits)

  /** Is this symbol `opaque` */
  def Opaque: Flags = Flags.wrap(quotes.reflect.Flags.Opaque)

  /** Is this symbol `open` */
  def Open: Flags = Flags.wrap(quotes.reflect.Flags.Open)

  /** Is this symbol `override` */
  def Override: Flags = Flags.wrap(quotes.reflect.Flags.Override)

  /** Is this symbol a package */
  def Package: Flags = Flags.wrap(quotes.reflect.Flags.Package)

  /** Is this symbol a parameter */
  def Param: Flags = Flags.wrap(quotes.reflect.Flags.Param)

  /** Is this symbol a parameter accessor */
  def ParamAccessor: Flags = Flags.wrap(quotes.reflect.Flags.ParamAccessor)

  /** Is this symbol `private` */
  def Private: Flags = Flags.wrap(quotes.reflect.Flags.Private)

  /** Is this symbol labeled private[this] */
  def PrivateLocal: Flags = Flags.wrap(quotes.reflect.Flags.PrivateLocal)

  /** Is this symbol `protected` */
  def Protected: Flags = Flags.wrap(quotes.reflect.Flags.Protected)

  /** Was this symbol imported from Scala2.x */
  def Scala2x: Flags = Flags.wrap(quotes.reflect.Flags.Scala2x)

  /** Is this symbol `sealed` */
  def Sealed: Flags = Flags.wrap(quotes.reflect.Flags.Sealed)

  /** Is this symbol member that is assumed to be stable and realizable */
  def StableRealizable: Flags = Flags.wrap(quotes.reflect.Flags.StableRealizable)

  /** Is this symbol to be tagged Java Synthetic */
  def Synthetic: Flags = Flags.wrap(quotes.reflect.Flags.Synthetic)

  /** Is this symbol a trait */
  def Trait: Flags = Flags.wrap(quotes.reflect.Flags.Trait)

  /** Is a transparent inline method or trait */
  def Transparent: Flags = Flags.wrap(quotes.reflect.Flags.Transparent)

}
